* Introduction
  project to implement extended kalman filter;
  subsidiary goals: get familiar with cmake, eigen, pybind11, python, catch2.

** Tools
   - nix    provides reproducible build/development environment
   - cmake  makefile generator
   - make   uses makefiles generated by cmake
   - git    source code control.
            see: https://www.freecodecamp.org/news/git-cheat-sheet-and-best-practices-c6ce5321f52/

** Libraries
   - catch2 unit test framework for c++
   - eigen  linear algebra library for c++

* Directory Layout
  kalman
  +- README                this file
  +- default.nix           controls hermetic build.   nix-build uses this
  +- shell.nix             controls interactive development environment.  nix-shell uses this
  +- kalman.nix            specifies dependencies + build scripts for this project
  +- mkderivation.nix      utility for kalman.nix
  +- builder.sh            build script; invoked from nix-build
  +- setup.sh              make shell environment for building;  called from builder.sh, shell.nix
  +- .gitignore            exclude generated files from git
  +- build                 run builds from here; excluded from git
  +- src/                  root of source tree
     +- CmakeLists.txt     configure cmake build
     +- KalmanConfig.h.in  configuration file template;  generates kalman/build/KalmanConfig.h
     +- matrix/
     +- tree/              red-black tree

* To build this project using nix:
   $ nix-build -A path/to/kalman

* To debug build / do development
   $ nix-shell -A path/to/kalman
   $ help
   $ emacs&          # edit files
   $ make -C kalman/build
  to attempt nix build
   $ do_all_phases   # shell function defined in setup.sh

* to run cmake
   $ nix-shell -A path/to/kalman
   $ cd path/to/kalman/build
   $ cmake -DEXPORT_COMPILE_COMMANDS=1 ../src

  subsequently can use:
   $ make -C path/to/kalman/build

  or
   $ make VERBOSE=1 -C path/to/kalman/build
  to see exact command log

* to add a library dependency foo

  1. find nix package for the dependency
     $ nix-env -qaP foo

  2. add depedency to kalman/kalman.nix, see buildInputs

     # kalman.nix
     ..
     buildInputs = localcxxdev ++ [ pkg-config eigen .. foo ];

  3. re-enter nix-shell to pickup kalman.nix changes

      $ cd proj/kalman
      $ nix-shell

     if package provides target directories,  then nix-shell will
     have added them to shell variables:
     - include/ directory   -> added to INCLUDEPATH
     - bin/ directory       -> added to PATH
     - pkgconfig/ directory -> added to PKG_CONFIG_PATH
     - lib/cmake directory  -> added to CMAKE_{INCLUDE,PREFIX,LIBRARY}_PATH

     (see kalman/setup.sh.  not sure how the cmake environment variables get set)

  4a. if new dependency has cmake integration:

      # path/to/subdir/CmakeLists.txt
      find_package(Foo REQUIRED)
     or
      find_package(Foo 2 REQUIRED) # to require version >= 2

     also need something like:
      target_include_directories(mytarget PUBLIC ${Foo_INCLUDE_DIRS})

     to get include paths to appear in kalman/build/compile_commands.json

  4b. if new dependency has pkgconfig integration:

      # path/to/subdir/CMakeLists.txt
      pkg_check_modules(FOO REQUIRED foo)
      target_include_directories(mytarget PUBLIC ${FOO_INCLUDE_DIRS})
      target_compile_options(mytarget PUBLIC ${FOO_CFLAGS_OTHER})

     here 'FOO' is prefix for cmake-generated make variables,
     and 'foo' is the package name to use with pkg-config,  e.g.

      $ pkg-config --cflags foo

     reports compiler flags using .pc files found in PKG_CONFIG_PATH

     (NOTE: can review cmake-generated make variables
            by inspecting kalman/build/CMakeCache.txt)
     
  